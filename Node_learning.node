https://nodejs.org/dist/latest-v10.x/docs/api/fs.html
https://stackoverflow.com/questions/14031763/doing-a-cleanup-action-just-before-node-js-exits
https://stackoverflow.com/questions/34082497/limit-node-js-memory-usage-to-less-than-300mb-per-process


        <OBJECT></OBJECT>
N               D
        E
summary of what I learned about a Node module        

        O
N               
        E
are tips

        O
N               D
        E
Node Errors

there are four types or erros in node

                        O

            Standard JavaScript errors
            System errors  like opening absent files
N           User-specified errors                            D
            Assertion Errors

                        E

they are at least guaranteed to provide the properties on the error class raised



        O
N               D
        E
Error Propagation and Interception

all errors caught by node generate a     throw exception
they will exit immediately With few exceptions, Synchronous APIs will use throw to report errors.


        O
N               D
        E
Reporting Async API errors
    sometimes the node function has a callback
    file /Error/simple_async_error.js

    sometimes your dealing with eventemitter objets.  errors can be routed to that object's 'error' event.
    file /Error/net_eventemitter_error.js

    look at each method to understand how their errors are handled
        
    the event-emitter and stream-based API are handled with the error event mechanism described in 
    file: /Error/net_eventemitter_error.js

    for event-emitters you need a handler registed for the uncaught Exception or an error will be thrown
    process.on('uncaughtException', function (err) { 
            console.log("a");   
    })    
    file: /Error/event_emitter_handler.js


        O
N               D
        E
Error-first callbacks
    if there is no error with these types of error handlers the first argument is null


                     O
    node_method.first_err([args], errorFirstCallback);
    function errorFirstCallback(err, data) {
      if (err) {
N        console.error('There was an error', err);     D
        return;
      }
    }    
    file: /Error/first_error_callback.js
                    E


        O
N           dont use try throw catch with async methods they do not work, register a handler with process.on('uncaughtException')
            process.on('uncaughtException', exitHandler.bind(null, {exit:true}));
        E    



        O
N               D
        E
Class: Error    

doesn't tell you why an error happened ' it just tells you the stack trace 
for crpyto, there is an additional stack called opensslErrorStack    


                                                O

            new Error(message)
N            makes a new Error object with a message, error.stack prorety contains a sync stack or        E
             the number of frames given by the property Error.stackTraceLimit which is smaller 

                                                D





                                                O

             Error.captureStackTrace(targetObject[, constructorOpt])
            when you call this you add a .stack property to an object it 
            like what happens when js tells you where an error happened
 N           file: /Error/capture_stack_trace.js                                              D

            use the The constructorOpt as fuction when 
            you want to hide error details from an end user 
            file: /Error/capture_stack_trace.js 

                                            E




                                                O
         Error.stackTraceLimit
         Tells you how many steps back it took to get to the error,  
N        if this is a neg or 0 the .stack property wont show anything                       D
         to change it   Error.stackTraceLimit = \d
         file: /Error/capture_stack_trace.js 

                                                E





                                                O

                 error.code 
N                most stable way to understand an error,                                     D
                 they only change between major node distributuions
                 to understand them:https://nodejs.org/dist/latest-v10.x/docs/api/errors.html#nodejs-error-codes
                     to access it it must be accessed through an error handler which catches the error object 
                     only then can you see the code
                 file: Error/first_error_callback.js


                                                E



                                                O
         error.message
 N       the message you add when making a new error, however changing this property may not   
         change the first line of the stack trace. if you call err.stack before changing the message,             D
         subsequent calls to err.stack will keep the orginal message                                                
        
                                                E




                                                O
        error.stack
        <string>
        all calls from beginning of program execution to where the error happened are listed. V8 handles this
        V8 tries to figure out the function names but when it cant is substitutes for <anonymous>
        Frames are only generated for JavaScript functions 
        if you have other embedded programming languages they will not pop up on the trace 
        file : Error/embedded_C_plus_plus_err_stack.js
N            location 
            native, if the frame represents a call internal to V8 (as in [].forEach).                                                   D
            plain-filename.js:line:column, if the frame represents a call internal to Node.js.
            /absolute/path/to/file.js:line:column, if the frame represents a call in a user program, or its dependencies
        the string is lazy generated
        number of frames Error.stackTraceLimit (see above)
        system-level errors are generated as augmented Error instances


                                                E




                                                O    

                Class: AssertionError
                https://nodejs.org/dist/latest-v10.x/docs/api/assert.html#assert_class_assert_assertionerror

                an error subclass that indicates an assertion failure 

                options <OBJECT></OBJECT>
                    message <string> a reg. error message
                    actual <any> 
                    expected <any>
N                   operator <string> which operator was used for the assertion 
                    stackStartFn <Function> removes frames unrelated to the start function where the assertion starts           D
                    code <string> always ERR_ASSERTION
                    generatedMessage <bool> if you cant see the message, this is helpful to 
                    debug why the assertion error message is notcomig up
                    file: Error/assertion_error.js


                                                E






                                                O                                                

                    Class: RangeError
                    when a node code gets a value outside the accetable ranges for its code 
                    Ex:
N                        require('net').connect(-1);                                                D
                        //ranges are 1- 65536
                        file:Error/simple_range_error.js


                                                E



                                                O

                    Class: ReferenceError
                    when you try to access an undefined variable 
N                    its a simple bug unless your are advanced and your software                    D
                    is generating and running code


                                                E




                                                O
        Class: SyntaxError
 N      when you have code that is not JavaScript and has no embedding support          D
        file: Error/simple_syntax_error.js                    

                                                E




                                        O

                     Class: TypeError
N                    when code gets an unwanted code type                 D
                     file: Error/simple_type_error                                                


                                        E




        O
N               D
        E
Exceptions vs. Errors      
a js exception means that something went wrong. they dont have to be shown as Errors, the practical difference is 
some erros are unrecoverable and will cause the process to crash, most can be handled  


        O
N               D
        E
                                                                O

                    System Errors
                    this happens when Node attempt to do things unallowed 
                    in the OS system environment its given
                    they are Error objects with more properties

                    Class: SystemError
                    error.address <string>
                    error.address  describing the address to which a network connection failed.
                    file: Error/system_errors.js

                    error.code<string>
                    it represents the error code
                    file: FS/simple_sync_fs.js

                    error.dest<string>
                    represents file destination with a file system error

N                                                                                                                              D
                    error.errno <string> | <number>
                    correspondes to error codes of the libuv library 
                    http://docs.libuv.org/en/v1.x/errors.html

                    error.info<Object>
                    gives details about the error

                    error.message<string>
                    human readable message about the Error

                    error.path<string>
                    info about an invalid path name 
                    file: Error/system_errors.js

                    error.port<number>
                    shows if there is an unavailable port involved

                    error.syscall<string>
                    a failed syscall
                    file: Error/net_eventemitter_error.js


                                                                E









                                                                O


                Common System Errors
                http://man7.org/linux/man-pages/man3/errno.3.html

                EACCES (Permission denied): An attempt was made to access a 
                file in a way forbidden by its file access permissions.

                EADDRINUSE (Address already in use):
                 An attempt to bind a server (net, http, or https) to a local address 
                failed due to another server on the local system already occupying that address.

                ECONNREFUSED (Connection refused): No connection could be made because
                 the target machine actively refused it. 
                This usually results from trying to connect to a service that is inactive on the foreign host.

                ECONNRESET (Connection reset by peer):
                 A connection was forcibly closed by a peer. This normally results 
                from a loss of the connection on the remote socket due to a timeout or reboot. 
                Commonly encountered via the http and net modules.

                EEXIST (File exists): An existing file was the target of an operation 
                that required that the target does not exist.
N
                EISDIR (Is a directory): An operation expected a file, 
                but the given pathname was a directory.
                                                                                                                        D                                D
                EMFILE (Too many open files in system): Maximum number of file
                 descriptors allowable on the system has been reached
                it will continue to raise unless a file gets closed .To remedy a  
                run ulimit -n [number] in the same shell that will run the Node.js process.

                ENOENT (No such file or directory): 

                ENOTDIR (Not a directory): 

                ENOTEMPTY (Directory not empty): required ususally by fs.unlink

                EPERM (Operation not permitted): 

                EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no process to read the data. 
                Commonly encountered at the net and http layers, indicative that 
                the remote side of the stream being written to has been closed.

                ETIMEDOUT (Operation timed out): A connect or send request failed because the connected party did not properly 
                respond after a period of time
                Usually encountered by http or net — often a sign that a socket.end() was not properly called.


                                                                        E


        O
N               D
        E
Node.js Error Codes
refer for other codes

ERR_ARG_NOT_ITERABLE
An iterable argument (i.e. a value that works with for...of loops) was required, 
but not provided to a Node.js API.
                         
ERR_ASSERTION
the assert error code

ERR_ASYNC_CALLBACK
register something that is not an async hook callback 

ERR_ASYNC_TYPE
invalid asynced resources

ERR_BUFFER_OUT_OF_BOUNDS
An operation outside the bounds of a Buffer was attempted

ERR_BUFFER_TOO_LARGE
trying to create a Buffer larger than the limit 

ERR_CANNOT_TRANSFER_OBJECT
The value passed to postMessage() 
contained an object that is not supported for transferring.   

ERR_CANNOT_WATCH_SIGINT
Node.js was unable to watch for the SIGINT signal.

ERR_CHILD_CLOSED_BEFORE_REPLY
A child process was closed before the parent received a reply.


ERR_CHILD_PROCESS_IPC_REQUIRED##
Used when a child process is being forked without specifying an IPC channel.

ERR_CHILD_PROCESS_STDIO_MAXBUFFER
when main process is trying to read a child stderr/stdout but data length longer than maxBuffer option 

ERR_CLOSED_MESSAGE_PORT
There was an attempt to use a MessagePort instance in a closed state, usually after .close() has been called.


ERR_CONSOLE_WRITABLE_STREAM##
Console was instantiated without stdout stream, or Console has a non-writable stdout or stderr stream. 

ERR_CONSTRUCT_CALL_REQUIRED
A constructor for a class was called without new.


ERR_CPU_USAGE##
The native call from process.cpuUsage could not be processed.


ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED##
A client certificate engine was requested that is not supported by the version of OpenSSL being used.


ERR_CRYPTO_ECDH_INVALID_FORMAT##
An invalid value for the format argument was passed to the crypto.ECDH() class getPublicKey() method.


ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY##
An invalid value for the key argument has been passed to the crypto.ECDH() class computeSecret() method. It means that the public key lies outside of the elliptic curve.


ERR_CRYPTO_ENGINE_UNKNOWN##
An invalid crypto engine identifier was passed to require('crypto').setEngine().


ERR_CRYPTO_FIPS_FORCED##
The --force-fips command-line argument was used but there was an attempt to enable or disable FIPS mode in the crypto module.


ERR_CRYPTO_FIPS_UNAVAILABLE##
An attempt was made to enable or disable FIPS mode, but FIPS mode was not available.


ERR_CRYPTO_HASH_DIGEST_NO_UTF16##
The UTF-16 encoding was used with hash.digest(). While the hash.digest() method does allow an encoding argument to be passed in, causing the method to return a string rather than a Buffer, the UTF-16 encoding (e.g. ucs or utf16le) is not supported.


ERR_CRYPTO_HASH_FINALIZED##
hash.digest() was called multiple times. The hash.digest() method must be called no more than one time per instance of a Hash object.


ERR_CRYPTO_HASH_UPDATE_FAILED##
hash.update() failed for any reason. This should rarely, if ever, happen.


ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS##
The selected public or private key encoding is incompatible with other options.


ERR_CRYPTO_INVALID_DIGEST##
An invalid crypto digest algorithm was specified.


ERR_CRYPTO_INVALID_STATE##
A crypto method was used on an object that was in an invalid state. For instance, calling cipher.getAuthTag() before calling cipher.final().


ERR_CRYPTO_PBKDF2_ERROR##
The PBKDF2 algorithm failed for unspecified reasons. OpenSSL does not provide more details and therefore neither does Node.js.


ERR_CRYPTO_SCRYPT_INVALID_PARAMETER##
One or more crypto.scrypt() or crypto.scryptSync() parameters are outside their legal range.


ERR_CRYPTO_SCRYPT_NOT_SUPPORTED##
Node.js was compiled without scrypt support. Not possible with the official release binaries but can happen with custom builds, including distro builds.


ERR_CRYPTO_SIGN_KEY_REQUIRED##
A signing key was not provided to the sign.sign() method.


ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH##
crypto.timingSafeEqual() was called with Buffer, TypedArray, or DataView arguments of different lengths.


ERR_DNS_SET_SERVERS_FAILED##
c-ares failed to set the DNS server.


ERR_DOMAIN_CALLBACK_NOT_AVAILABLE##
The domain module was not usable since it could not establish the required error handling hooks, because process.setUncaughtExceptionCaptureCallback() had been called at an earlier point in time.


ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE##
process.setUncaughtExceptionCaptureCallback() could not be called because the domain module has been loaded at an earlier point in time.

The stack trace is extended to include the point in time at which the domain module had been loaded.


ERR_ENCODING_INVALID_ENCODED_DATA##
Data provided to util.TextDecoder() API was invalid according to the encoding provided.


ERR_ENCODING_NOT_SUPPORTED##
Encoding provided to util.TextDecoder() API was not one of the WHATWG Supported Encodings.


ERR_FALSY_VALUE_REJECTION##
A Promise that was callbackified via util.callbackify() was rejected with a falsy value.


ERR_FS_FILE_TOO_LARGE##
An attempt has been made to read a file whose size is larger than the maximum allowed size for a Buffer.


ERR_FS_INVALID_SYMLINK_TYPE##
An invalid symlink type was passed to the fs.symlink() or fs.symlinkSync() methods.


ERR_HTTP_HEADERS_SENT##
An attempt was made to add more headers after the headers had already been sent.


ERR_HTTP_INVALID_HEADER_VALUE##
An invalid HTTP header value was specified.


ERR_HTTP_INVALID_STATUS_CODE##
Status code was outside the regular status code range (100-999).


ERR_HTTP_TRAILER_INVALID##
The Trailer header was set even though the transfer encoding does not support that.


ERR_HTTP2_ALTSVC_INVALID_ORIGIN##
HTTP/2 ALTSVC frames require a valid origin.


ERR_HTTP2_ALTSVC_LENGTH##
HTTP/2 ALTSVC frames are limited to a maximum of 16,382 payload bytes.


ERR_HTTP2_CONNECT_AUTHORITY##
For HTTP/2 requests using the CONNECT method, the :authority pseudo-header is required.


ERR_HTTP2_CONNECT_PATH##
For HTTP/2 requests using the CONNECT method, the :path pseudo-header is forbidden.


ERR_HTTP2_CONNECT_SCHEME##
For HTTP/2 requests using the CONNECT method, the :scheme pseudo-header is forbidden.


ERR_HTTP2_ERROR##
A non-specific HTTP/2 error has occurred.


ERR_HTTP2_GOAWAY_SESSION##
New HTTP/2 Streams may not be opened after the Http2Session has received a GOAWAY frame from the connected peer.


ERR_HTTP2_HEADERS_AFTER_RESPOND##
An additional headers was specified after an HTTP/2 response was initiated.


ERR_HTTP2_HEADERS_SENT##
An attempt was made to send multiple response headers.


ERR_HTTP2_HEADER_SINGLE_VALUE##
Multiple values were provided for an HTTP/2 header field that was required to have only a single value.


ERR_HTTP2_INFO_STATUS_NOT_ALLOWED##
Informational HTTP status codes (1xx) may not be set as the response status code on HTTP/2 responses.


ERR_HTTP2_INVALID_CONNECTION_HEADERS##
HTTP/1 connection specific headers are forbidden to be used in HTTP/2 requests and responses.


ERR_HTTP2_INVALID_HEADER_VALUE##
An invalid HTTP/2 header value was specified.


ERR_HTTP2_INVALID_INFO_STATUS##
An invalid HTTP informational status code has been specified. Informational status codes must be an integer between 100 and 199 (inclusive).


ERR_HTTP2_INVALID_ORIGIN##
HTTP/2 ORIGIN frames require a valid origin.


ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH##
Input Buffer and Uint8Array instances passed to the http2.getUnpackedSettings() API must have a length that is a multiple of six.


ERR_HTTP2_INVALID_PSEUDOHEADER##
Only valid HTTP/2 pseudoheaders (:status, :path, :authority, :scheme, and :method) may be used.


ERR_HTTP2_INVALID_SESSION##
An action was performed on an Http2Session object that had already been destroyed.


ERR_HTTP2_INVALID_SETTING_VALUE##
An invalid value has been specified for an HTTP/2 setting.


ERR_HTTP2_INVALID_STREAM##
An operation was performed on a stream that had already been destroyed.


ERR_HTTP2_MAX_PENDING_SETTINGS_ACK##
Whenever an HTTP/2 SETTINGS frame is sent to a connected peer, the peer is required to send an acknowledgment that it has received and applied the new SETTINGS. By default, a maximum number of unacknowledged SETTINGS frames may be sent at any given time. This error code is used when that limit has been reached.


ERR_HTTP2_NESTED_PUSH##
An attempt was made to initiate a new push stream from within a push stream. Nested push streams are not permitted.


ERR_HTTP2_NO_SOCKET_MANIPULATION##
An attempt was made to directly manipulate (read, write, pause, resume, etc.) a socket attached to an Http2Session.


ERR_HTTP2_ORIGIN_LENGTH##
HTTP/2 ORIGIN frames are limited to a length of 16382 bytes.


ERR_HTTP2_OUT_OF_STREAMS##
The number of streams created on a single HTTP/2 session reached the maximum limit.


ERR_HTTP2_PAYLOAD_FORBIDDEN##
A message payload was specified for an HTTP response code for which a payload is forbidden.


ERR_HTTP2_PING_CANCEL##
An HTTP/2 ping was canceled.


ERR_HTTP2_PING_LENGTH##
HTTP/2 ping payloads must be exactly 8 bytes in length.


ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED##
An HTTP/2 pseudo-header has been used inappropriately. Pseudo-headers are header key names that begin with the : prefix.


ERR_HTTP2_PUSH_DISABLED##
An attempt was made to create a push stream, which had been disabled by the client.


ERR_HTTP2_SEND_FILE##
An attempt was made to use the Http2Stream.prototype.responseWithFile() API to send a directory.


ERR_HTTP2_SEND_FILE_NOSEEK##
An attempt was made to use the Http2Stream.prototype.responseWithFile() API to send something other than a regular file, but offset or length options were provided.


ERR_HTTP2_SESSION_ERROR##
The Http2Session closed with a non-zero error code.


ERR_HTTP2_SETTINGS_CANCEL##
The Http2Session settings canceled.


ERR_HTTP2_SOCKET_BOUND##
An attempt was made to connect a Http2Session object to a net.Socket or tls.TLSSocket that had already been bound to another Http2Session object.


ERR_HTTP2_SOCKET_UNBOUND##
An attempt was made to use the socket property of an Http2Session that has already been closed.


ERR_HTTP2_STATUS_101##
Use of the 101 Informational status code is forbidden in HTTP/2.


ERR_HTTP2_STATUS_INVALID##
An invalid HTTP status code has been specified. Status codes must be an integer between 100 and 599 (inclusive).


ERR_HTTP2_STREAM_CANCEL##
An Http2Stream was destroyed before any data was transmitted to the connected peer.


ERR_HTTP2_STREAM_ERROR##
A non-zero error code was been specified in an RST_STREAM frame.


ERR_HTTP2_STREAM_SELF_DEPENDENCY##
When setting the priority for an HTTP/2 stream, the stream may be marked as a dependency for a parent stream. This error code is used when an attempt is made to mark a stream and dependent of itself.


ERR_HTTP2_TRAILERS_ALREADY_SENT##
Trailing headers have already been sent on the Http2Stream.


ERR_HTTP2_TRAILERS_NOT_READY##
The http2stream.sendTrailers() method cannot be called until after the 'wantTrailers' event is emitted on an Http2Stream object. The 'wantTrailers' event will only be emitted if the waitForTrailers option is set for the Http2Stream.


ERR_HTTP2_UNSUPPORTED_PROTOCOL##
http2.connect() was passed a URL that uses any protocol other than http: or https:.


ERR_INDEX_OUT_OF_RANGE##
A given index was out of the accepted range (e.g. negative offsets).


ERR_INSPECTOR_ALREADY_CONNECTED##
While using the inspector module, an attempt was made to connect when the inspector was already connected.


ERR_INSPECTOR_CLOSED##
While using the inspector module, an attempt was made to use the inspector after the session had already closed.


ERR_INSPECTOR_NOT_AVAILABLE##
The inspector module is not available for use.


ERR_INSPECTOR_NOT_CONNECTED##
While using the inspector module, an attempt was made to use the inspector before it was connected.


ERR_INVALID_ADDRESS_FAMILY##
The provided address family is not understood by the Node.js API.


ERR_INVALID_ARG_TYPE##
An argument of the wrong type was passed to a Node.js API.


ERR_INVALID_ARG_VALUE##
An invalid or unsupported value was passed for a given argument.


ERR_INVALID_ARRAY_LENGTH##
An array was not of the expected length or in a valid range.


ERR_INVALID_ASYNC_ID##
An invalid asyncId or triggerAsyncId was passed using AsyncHooks. An id less than -1 should never happen.


ERR_INVALID_BUFFER_SIZE##
A swap was performed on a Buffer but its size was not compatible with the operation.


ERR_INVALID_CALLBACK##
A callback function was required but was not been provided to a Node.js API.


ERR_INVALID_CHAR##
Invalid characters were detected in headers.


ERR_INVALID_CURSOR_POS##
A cursor on a given stream cannot be moved to a specified row without a specified column.


ERR_INVALID_DOMAIN_NAME##
hostname can not be parsed from a provided URL.


ERR_INVALID_FD##
A file descriptor ('fd') was not valid (e.g. it was a negative value).


ERR_INVALID_FD_TYPE##
A file descriptor ('fd') type was not valid.


ERR_INVALID_FILE_URL_HOST##
A Node.js API that consumes file: URLs (such as certain functions in the fs module) encountered a file URL with an incompatible host. This situation can only occur on Unix-like systems where only localhost or an empty host is supported.


ERR_INVALID_FILE_URL_PATH##
A Node.js API that consumes file: URLs (such as certain functions in the fs module) encountered a file URL with an incompatible path. The exact semantics for determining whether a path can be used is platform-dependent.


ERR_INVALID_HANDLE_TYPE##
An attempt was made to send an unsupported "handle" over an IPC communication channel to a child process. See subprocess.send() and process.send() for more information.


ERR_INVALID_HTTP_TOKEN##
An invalid HTTP token was supplied.


ERR_INVALID_IP_ADDRESS##
An IP address is not valid.


ERR_INVALID_OPT_VALUE##
An invalid or unexpected value was passed in an options object.


ERR_INVALID_OPT_VALUE_ENCODING##
An invalid or unknown file encoding was passed.


ERR_INVALID_PERFORMANCE_MARK##
While using the Performance Timing API (perf_hooks), a performance mark is invalid.


ERR_INVALID_PROTOCOL##
An invalid options.protocol was passed.


ERR_INVALID_REPL_EVAL_CONFIG##
Both breakEvalOnSigint and eval options were set in the REPL config, which is not supported.


ERR_INVALID_RETURN_PROPERTY##
Thrown in case a function option does not provide a valid value for one of its returned object properties on execution.


ERR_INVALID_RETURN_PROPERTY_VALUE##
Thrown in case a function option does not provide an expected value type for one of its returned object properties on execution.


ERR_INVALID_RETURN_VALUE##
Thrown in case a function option does not return an expected value type on execution, such as when a function is expected to return a promise.


ERR_INVALID_SYNC_FORK_INPUT##
A Buffer, TypedArray, DataView or string was provided as stdio input to an async fork. See the documentation for the child_process module for more information.


ERR_INVALID_THIS##
A Node.js API function was called with an incompatible this value.
file: Error/err_invalid_this.js

ERR_INVALID_TRANSFER_OBJECT##
An invalid transfer object was passed to postMessage().


ERR_INVALID_TUPLE##
An element in the iterable provided to the WHATWG URLSearchParams constructor did not represent a [name, value] tuple – that is, if an element is not iterable, or does not consist of exactly two elements.


ERR_INVALID_URI##
An invalid URI was passed.

ERR_INVALID_TRANSFER_OBJECT

ERR_INVALID_TRANSFER_OBJECT##
An invalid transfer object was passed to postMessage().


ERR_INVALID_TUPLE##
An element in the iterable provided to the WHATWG URLSearchParams constructor did not represent a [name, value] tuple – that is, if an element is not iterable, or does not consist of exactly two elements.


ERR_INVALID_URI##
An invalid URI was passed.


ERR_INVALID_URL##
An invalid URL was passed to the WHATWG URL constructor to be parsed. The thrown error object typically has an additional property 'input' that contains the URL that failed to parse.


ERR_INVALID_URL_SCHEME##
An attempt was made to use a URL of an incompatible scheme (protocol) for a specific purpose. It is only used in the WHATWG URL API support in the fs module (which only accepts URLs with 'file' scheme), but may be used in other Node.js APIs as well in the future.


ERR_IPC_CHANNEL_CLOSED##
An attempt was made to use an IPC communication channel that was already closed.


ERR_IPC_DISCONNECTED##
An attempt was made to disconnect an IPC communication channel that was already disconnected. See the documentation for the child_process module for more information.


ERR_IPC_ONE_PIPE##
An attempt was made to create a child Node.js process using more than one IPC communication channel. See the documentation for the child_process module for more information.


ERR_IPC_SYNC_FORK##
An attempt was made to open an IPC communication channel with a synchronously forked Node.js process. See the documentation for the child_process module for more information.


ERR_MEMORY_ALLOCATION_FAILED##
An attempt was made to allocate memory (usually in the C++ layer) but it failed.


ERR_METHOD_NOT_IMPLEMENTED##
A method is required but not implemented.


ERR_MISSING_ARGS##
A required argument of a Node.js API was not passed. This is only used for strict compliance with the API specification (which in some cases may accept func(undefined) but not func()). In most native Node.js APIs, func(undefined) and func() are treated identically, and the ERR_INVALID_ARG_TYPE error code may be used instead.


ERR_MISSING_DYNAMIC_INSTANTIATE_HOOK##
Stability: 1 - Experimental
An ES6 module loader hook specified format: 'dynamic' but did not provide a dynamicInstantiate hook.


ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST##
A MessagePort was found in the object passed to a postMessage() call, but not provided in the transferList for that call.


ERR_MISSING_MODULE##
Stability: 1 - Experimental
An ES6 module could not be resolved.


ERR_MISSING_PLATFORM_FOR_WORKER##
The V8 platform used by this instance of Node.js does not support creating Workers. This is caused by lack of embedder support for Workers. In particular, this error will not occur with standard builds of Node.js.


ERR_MODULE_RESOLUTION_LEGACY##
Stability: 1 - Experimental
A failure occurred resolving imports in an ES6 module.


ERR_MULTIPLE_CALLBACK##
A callback was called more than once.

A callback is almost always meant to only be called once as the query can either be fulfilled or rejected but not both at the same time. The latter would be possible by calling a callback more than once.


ERR_NAPI_CONS_FUNCTION##
While using N-API, a constructor passed was not a function.


ERR_NAPI_INVALID_DATAVIEW_ARGS##
While calling napi_create_dataview(), a given offset was outside the bounds of the dataview or offset + length was larger than a length of given buffer.


ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT##
While calling napi_create_typedarray(), the provided offset was not a multiple of the element size.


ERR_NAPI_INVALID_TYPEDARRAY_LENGTH##
While calling napi_create_typedarray(), (length * size_of_element) + byte_offset was larger than the length of given buffer.


ERR_NAPI_TSFN_CALL_JS##
An error occurred while invoking the JavaScript portion of the thread-safe function.


ERR_NAPI_TSFN_GET_UNDEFINED##
An error occurred while attempting to retrieve the JavaScript undefined value.


ERR_NAPI_TSFN_START_IDLE_LOOP##
On the main thread, values are removed from the queue associated with the thread-safe function in an idle loop. This error indicates that an error has occurred when attempting to start the loop.


ERR_NAPI_TSFN_STOP_IDLE_LOOP##
Once no more items are left in the queue, the idle loop must be suspended. This error indicates that the idle loop has failed to stop.


ERR_NO_CRYPTO##
An attempt was made to use crypto features while Node.js was not compiled with OpenSSL crypto support.


ERR_NO_ICU##
An attempt was made to use features that require ICU, but Node.js was not compiled with ICU support.


ERR_NO_LONGER_SUPPORTED##
A Node.js API was called in an unsupported manner, such as Buffer.write(string, encoding, offset[, length]).


ERR_OUT_OF_RANGE##
A given value is out of the accepted range.


ERR_REQUIRE_ESM##
Stability: 1 - Experimental
An attempt was made to require() an ES6 module.


ERR_SCRIPT_EXECUTION_INTERRUPTED##
Script execution was interrupted by SIGINT (For example, when Ctrl+C was pressed).


ERR_SERVER_ALREADY_LISTEN##
The server.listen() method was called while a net.Server was already listening. This applies to all instances of net.Server, including HTTP, HTTPS, and HTTP/2 Server instances.


ERR_SERVER_NOT_RUNNING##
The server.close() method was called when a net.Server was not running. This applies to all instances of net.Server, including HTTP, HTTPS, and HTTP/2 Server instances.


ERR_SOCKET_ALREADY_BOUND##
An attempt was made to bind a socket that has already been bound.


ERR_SOCKET_BAD_BUFFER_SIZE##
An invalid (negative) size was passed for either the recvBufferSize or sendBufferSize options in dgram.createSocket().


ERR_SOCKET_BAD_PORT##
An API function expecting a port >= 0 and < 65536 received an invalid value.


ERR_SOCKET_BAD_TYPE##
An API function expecting a socket type (udp4 or udp6) received an invalid value.


ERR_SOCKET_BUFFER_SIZE##
While using dgram.createSocket(), the size of the receive or send Buffer could not be determined.


ERR_SOCKET_CANNOT_SEND##
Data could be sent on a socket.


ERR_SOCKET_CLOSED##
An attempt was made to operate on an already closed socket.


ERR_SOCKET_DGRAM_NOT_RUNNING##
A call was made and the UDP subsystem was not running.


ERR_STREAM_CANNOT_PIPE##
An attempt was made to call stream.pipe() on a Writable stream.


ERR_STREAM_DESTROYED##
A stream method was called that cannot complete because the stream was destroyed using stream.destroy().


ERR_STREAM_NULL_VALUES##
An attempt was made to call stream.write() with a null chunk.


ERR_STREAM_PREMATURE_CLOSE##
An error returned by stream.finished() and stream.pipeline(), when a stream or a pipeline ends non gracefully with no explicit error.


ERR_STREAM_PUSH_AFTER_EOF##
An attempt was made to call stream.push() after a null(EOF) had been pushed to the stream.


ERR_STREAM_UNSHIFT_AFTER_END_EVENT##
An attempt was made to call stream.unshift() after the 'end' event was emitted.


ERR_STREAM_WRAP##
Prevents an abort if a string decoder was set on the Socket or if the decoder is in objectMode.

const Socket = require('net').Socket;
const instance = new Socket();

instance.setEncoding('utf8');

ERR_STREAM_WRITE_AFTER_END##
An attempt was made to call stream.write() after stream.end() has been called.


ERR_STRING_TOO_LONG##
An attempt has been made to create a string longer than the maximum allowed length.


ERR_SYSTEM_ERROR##
An unspecified or non-specific system error has occurred within the Node.js process. The error object will have an err.info object property with additional details.


ERR_TLS_CERT_ALTNAME_INVALID##
While using TLS, the hostname/IP of the peer did not match any of the subjectAltNames in its certificate.


ERR_TLS_DH_PARAM_SIZE##
While using TLS, the parameter offered for the Diffie-Hellman (DH) key-agreement protocol is too small. By default, the key length must be greater than or equal to 1024 bits to avoid vulnerabilities, even though it is strongly recommended to use 2048 bits or larger for stronger security.


ERR_TLS_HANDSHAKE_TIMEOUT##
A TLS/SSL handshake timed out. In this case, the server must also abort the connection.


ERR_TLS_RENEGOTIATE##
An attempt to renegotiate the TLS session failed.


ERR_TLS_RENEGOTIATION_DISABLED##
An attempt was made to renegotiate TLS on a socket instance with TLS disabled.


ERR_TLS_REQUIRED_SERVER_NAME##
While using TLS, the server.addContext() method was called without providing a hostname in the first parameter.


ERR_TLS_SESSION_ATTACK##
An excessive amount of TLS renegotiations is detected, which is a potential vector for denial-of-service attacks.


ERR_TLS_SNI_FROM_SERVER##
An attempt was made to issue Server Name Indication from a TLS server-side socket, which is only valid from a client.


ERR_TRACE_EVENTS_CATEGORY_REQUIRED##
The trace_events.createTracing() method requires at least one trace event category.


ERR_TRACE_EVENTS_UNAVAILABLE##
The trace_events module could not be loaded because Node.js was compiled with the --without-v8-platform flag.


ERR_TRANSFERRING_EXTERNALIZED_SHAREDARRAYBUFFER##
A SharedArrayBuffer whose memory is not managed by the JavaScript engine or by Node.js was encountered during serialization. Such a SharedArrayBuffer cannot be serialized.

This can only happen when native addons create SharedArrayBuffers in "externalized" mode, or put existing SharedArrayBuffer into externalized mode.


ERR_TRANSFORM_ALREADY_TRANSFORMING##
A Transform stream finished while it was still transforming.


ERR_TRANSFORM_WITH_LENGTH_0##
A Transform stream finished with data still in the write buffer.


ERR_TTY_INIT_FAILED##
The initialization of a TTY failed due to a system error.


ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET##
process.setUncaughtExceptionCaptureCallback() was called twice, without first resetting the callback to null.

This error is designed to prevent accidentally overwriting a callback registered from another module.


ERR_UNESCAPED_CHARACTERS##
A string that contained unescaped characters was received.


ERR_UNHANDLED_ERROR##
An unhandled error occurred (for instance, when an 'error' event is emitted by an EventEmitter but an 'error' handler is not registered).


ERR_UNKNOWN_BUILTIN_MODULE##
Used to identify a specific kind of internal Node.js error that should not typically be triggered by user code. Instances of this error point to an internal bug within the Node.js binary itself.


ERR_UNKNOWN_ENCODING##
An invalid or unknown encoding option was passed to an API.


ERR_UNKNOWN_FILE_EXTENSION##
Stability: 1 - Experimental
An attempt was made to load a module with an unknown or unsupported file extension.


ERR_UNKNOWN_MODULE_FORMAT##
Stability: 1 - Experimental
An attempt was made to load a module with an unknown or unsupported format.


ERR_UNKNOWN_SIGNAL##
An invalid or unknown process signal was passed to an API expecting a valid signal (such as subprocess.kill()).


ERR_UNKNOWN_STDIN_TYPE##
An attempt was made to launch a Node.js process with an unknown stdin file type. This error is usually an indication of a bug within Node.js itself, although it is possible for user code to trigger it.


ERR_UNKNOWN_STREAM_TYPE##
An attempt was made to launch a Node.js process with an unknown stdout or stderr file type. This error is usually an indication of a bug within Node.js itself, although it is possible for user code to trigger it.


ERR_V8BREAKITERATOR##
The V8 BreakIterator API was used but the full ICU data set is not installed.


ERR_VALID_PERFORMANCE_ENTRY_TYPE##
While using the Performance Timing API (perf_hooks), no valid performance entry types were found.


ERR_VM_MODULE_ALREADY_LINKED##
The module attempted to be linked is not eligible for linking, because of one of the following reasons:

It has already been linked (linkingStatus is 'linked')
It is being linked (linkingStatus is 'linking')
Linking has failed for this module (linkingStatus is 'errored')

ERR_VM_MODULE_DIFFERENT_CONTEXT##
The module being returned from the linker function is from a different context than the parent module. Linked modules must share the same context.


ERR_VM_MODULE_LINKING_ERRORED##
The linker function returned a module for which linking has failed.


ERR_VM_MODULE_NOT_LINKED##
The module must be successfully linked before instantiation.


ERR_VM_MODULE_NOT_MODULE##
The fulfilled value of a linking promise is not a vm.SourceTextModule object.


ERR_VM_MODULE_STATUS##
The current module's status does not allow for this operation. The specific meaning of the error depends on the specific function.


ERR_WORKER_PATH##
The path for the main script of a worker is neither an absolute path nor a relative path starting with ./ or ../.


ERR_WORKER_UNSERIALIZABLE_ERROR##
All attempts at serializing an uncaught exception from a worker thread failed.


ERR_WORKER_UNSUPPORTED_EXTENSION##
The pathname used for the main script of a worker has an unknown file extension.


ERR_ZLIB_INITIALIZATION_FAILED##
Creation of a zlib object failed due to incorrect configuration.


HPE_HEADER_OVERFLOW#
History
Too much HTTP header data was received. In order to protect against malicious or malconfigured clients, if more than 8KB of HTTP header data is received then HTTP parsing will abort without a request or response object being created, and an Error with this code will be emitted.


MODULE_NOT_FOUND#
A module file could not be resolved while attempting a require() or import operation.




        O
N               D
        E
Legacy Node.js Error Codes#
Stability: 0 - Deprecated. These error codes are either inconsistent, or have been removed.

ERR_HTTP2_FRAME_ERROR##
Added in: v9.0.0Removed in: v10.0.0
Used when a failure occurs sending an individual frame on the HTTP/2 session.


ERR_HTTP2_HEADERS_OBJECT##
Added in: v9.0.0Removed in: v10.0.0
Used when an HTTP/2 Headers Object is expected.


ERR_HTTP2_HEADER_REQUIRED##
Added in: v9.0.0Removed in: v10.0.0
Used when a required header is missing in an HTTP/2 message.


ERR_HTTP2_INFO_HEADERS_AFTER_RESPOND##
Added in: v9.0.0Removed in: v10.0.0
HTTP/2 informational headers must only be sent prior to calling the Http2Stream.prototype.respond() method.


ERR_HTTP2_STREAM_CLOSED##
Added in: v9.0.0Removed in: v10.0.0
Used when an action has been performed on an HTTP/2 Stream that has already been closed.


ERR_HTTP_INVALID_CHAR##
Added in: v9.0.0Removed in: v10.0.0
Used when an invalid character is found in an HTTP response status message (reason phrase).


ERR_NAPI_CONS_PROTOTYPE_OBJECT##
Added in: v9.0.0Removed in: v10.0.0
Used by the N-API when Constructor.prototype is not an object.


ERR_OUTOFMEMORY##
Added in: v9.0.0Removed in: v10.0.0
Used generically to identify that an operation caused an out of memory condition.


ERR_PARSE_HISTORY_DATA##
Added in: v9.0.0Removed in: v10.0.0
The repl module was unable to parse data from the REPL history file.


ERR_STDERR_CLOSE##
History
An attempt was made to close the process.stderr stream. By design, Node.js does not allow stdout or stderr streams to be closed by user code.


ERR_STDOUT_CLOSE##
History
An attempt was made to close the process.stdout stream. By design, Node.js does not allow stdout or stderr streams to be closed by user code.


ERR_STREAM_READ_NOT_IMPLEMENTED##
Added in: v9.0.0Removed in: v10.0.0
Used when an attempt is made to use a readable stream that has not implemented readable._read().


ERR_TLS_RENEGOTIATION_FAILED##
Added in: v9.0.0Removed in: v10.0.0
Used when a TLS renegotiation request has failed in a non-specific way.


ERR_UNKNOWN_BUILTIN_MODULE##
Added in: v8.0.0Removed in: v9.0.0
The 'ERR_UNKNOWN_BUILTIN_MODULE' error code is used to identify a specific kind of internal Node.js error that should not typically be triggered by user code. Instances of this error point to an internal bug within the Node.js binary itself.


ERR_VALUE_OUT_OF_RANGE##
Added in: v9.0.0Removed in: v10.0.0
Used when a given value is out of the accepted range.


ERR_ZLIB_BINDING_CLOSED##
Added in: v9.0.0Removed in: v10.0.0
Used when an attempt is made to use a zlib object after it has already been closed.

Other error codes#
These errors have never been released, but had been present on master between releases.


ERR_FS_WATCHER_ALREADY_STARTED##
An attempt was made to start a watcher returned by fs.watch() that has already been started.


ERR_FS_WATCHER_NOT_STARTED##
An attempt was made to initiate operations on a watcher returned by fs.watch() that has not yet been started.


ERR_HTTP2_ALREADY_SHUTDOWN##
Occurs with multiple attempts to shutdown an HTTP/2 session.


ERR_HTTP2_ERROR##
A non-specific HTTP/2 error has occurred.


ERR_INVALID_REPL_HISTORY##
Used in the repl in case the old history file is used and an error occurred while trying to read and parse it.


ERR_MISSING_DYNAMIC_INSTANTIATE_HOOK##
Used when an ES6 module loader hook specifies format: 'dynamic' but does not provide a dynamicInstantiate hook.


ERR_STREAM_HAS_STRINGDECODER##
Used to prevent an abort if a string decoder was set on the Socket.

const Socket = require('net').Socket;
const instance = new Socket();

instance.setEncoding('utf8');

ERR_STRING_TOO_LARGE##
An attempt has been made to create a string larger than the maximum allowed size.        



        <OBJECT></OBJECT>
N               D
        E
What I take away from error handling
for async errors use a error handler which has an if else handling things
for event emitters and streams use process.on('uncaughtException', () => { //handler})       
for sync erros use try, catch throw 
for every method you use research how it tells you to handle its errors  


















<NAV></NAV>
<object></object>
function
Error





        O
N               D
        E
Node filesystem

All file system operations have synchronous and asynchronous forms.
                                            O

                                                                                                                                               

                The asynchronous form always takes a completion callback as its last argument, 
                the exception is the 1st arg of the callback

                if there is no exception the first arg is null
N                                                                                                           D
                const fs = require('fs');

                fs.async_function('/tmasfasfp/hasdasello', (err) => {
                  if (err) throw err;
                  else{
                        console.log('successfully deleted /tmp/hello');
                  } 
                });
                file: FS/simple_async_fs.js


                                            E





                                            O


                    sync exceptions are thrown immediately, 
                    use try catch throw finally here and they can bubble up

                    try {
N                     fs.Syncfunction('/tmpasdasda/hello');                            D
                      console.log('successfully executed');
                    } 

                    catch (err) {
                      console.log(err.code)
                    }
                    file: FS/simple_sync_fs.js


                                            E







        O
N           to bubble up means any thing as the cause of code deep in your software will bubble to the parent (the surface)
            if the code closer to the surface above it needs any data it sends 
        E





                                        O


                    if you want your async function done 
                    in order use them with callback logic 



N                   fs.rename('/tmp/hello', '/tmp/world', (err) => {               D
                      if (err) throw err;
                      fs.stat('/tmp/world', (err, stats) => {
                        if (err) throw err;
                        console.log(`stats: ${JSON.stringify(stats)}`);
                      });
                    });
                    file: FS/async_by_callback.js

                    use async code in production, sync version will block 
                    till they complete

                    always use callback for async fucntions, Idc if your code is one big chain it works, 


                                        E




        O
N               D
        E



                                                                O

                    File Paths
                    Most fs operations accept filepaths that may be specified 
                    in the form of a string, a Buffer, or a URL object using the file: protocol.        

                    String form paths are interpreted as UTF-8 character sequences 
                    identifying the absolute or relative filename. 
                    Relative paths will be resolved relative to the current working 
                    directory as specified by process.cwd().
                    file: /FS/abs_path.js    /FS/relative_path.js
N                                                                                                                           D
    
                    Paths specified using a Buffer are useful primarily on 
                    certain POSIX operating systems that treat file paths as opaque byte sequences
                    Buffer paths can also be relative or absolute

                    file: /FS/rel_and_abs_buffer_path.js

                    on Windows there is a per-drive working dir concept Node follows
                     For example fs.readdirSync('c:\\') can potentially return 
                     a different result than fs.readdirSync('c:')


                                                                E


        O
N               D
        E





                                                    O

                    URL object support
                    Added in: v7.6.0

                    only file paths with the file:// URL are supported,
                     they are  the WHATWG URL object while node referres to files like this
                     file: FS/URL_basic_fs.js


                    On Windows, file: URLs with a hostname convert to UNC paths, while file: 
                    URLs with drive letters convert to local absolute paths
                    . file: URLs without a hostname nor a drive letter will result in a throw:
N                                                                                                               D

                    file: URLs with a hostname are unsupported and will result in a throw:
                    ex. 
                            fs.readFileSync(new URL('file://hostname/p/a/t/h/file'));

                    A file: URL having encoded slash characters will result in a throw on all platforms:
                    ex. 

                            fs.readFileSync(new URL('file:///p/a/t/h/%2F'));
                            fs.readFileSync(new URL('file:///p/a/t/h/%2f')); 

                                                E        

        O
N               D
        E

        

                                                        O

                File Descriptors                                                                    
                on POSIX for every process working with files there is a file descriptor for each file to help the 
                system keep track of whats happening to files 

                Node.js makes it simple 
N                                                                                                                          D
                fs.open() is used to get a file descriptor, once node has given this to a file 
                it can do anything to the file in permission bounds 
                file: FS/open_basic.js 

                many OS  limit the amount of open files at a given time, remember to close files 
                when you  are done with them and have a error  handler that closes any files if errors are  caught

                                                        E                

        O
N               D
        E

Threadpool Usage

All file system APIs except fs.FSWatcher() and those that are explicitly synchronous use 
libuv's threadpool', which can have surprising and negative performance implications for some applications

to mitigate make the size larger than 4 the make value for UV_THREADPOOL_SIZE=size is 128   



        O
N               D
        E


Class: fs.Dirent#
Added in: v10.10.0
When fs.readdir() or fs.readdirSync() is called with the withFileTypes option set to true, 
the resulting array is filled with fs.Dirent objects, rather than strings or Buffers.           

dirent.isBlockDevice()#
Added in: v10.10.0
Returns: <boolean>
Returns true if the fs.Dirent object describes a block device.

dirent.isCharacterDevice()#
Added in: v10.10.0
Returns: <boolean>
Returns true if the fs.Dirent object describes a character device.

dirent.isDirectory()#
Added in: v10.10.0
Returns: <boolean>
Returns true if the fs.Dirent object describes a file system directory.

dirent.isFIFO()#
Added in: v10.10.0
Returns: <boolean>
Returns true if the fs.Dirent object describes a first-in-first-out (FIFO) pipe.

dirent.isFile()#
Added in: v10.10.0
Returns: <boolean>
Returns true if the fs.Dirent object describes a regular file.

dirent.isSocket()#
Added in: v10.10.0
Returns: <boolean>
Returns true if the fs.Dirent object describes a socket.

dirent.isSymbolicLink()#
Added in: v10.10.0
Returns: <boolean>
Returns true if the fs.Dirent object describes a symbolic link.

dirent.name#
Added in: v10.10.0
<string> | <Buffer>
The file name that this fs.Dirent object refers to. The type of 
this value is determined by the options.encoding passed to fs.readdir() or fs.readdirSync().                                           







        O
N               D
        E


Class: fs.ReadStream

A successful call to fs.createReadStream() 
will return a new fs.ReadStream object.

All fs.ReadStream objects are Readable Streams.

Event: 'close'#
Added in: v0.1.93
Emitted when the fs.ReadStream's underlying file descriptor has been closed.

Event: 'open'#
Added in: v0.1.93
fd <integer> Integer file descriptor used by the ReadStream.
Emitted when the fs.ReadStream's file descriptor has been opened.

Event: 'ready'#
Added in: v9.11.0
Emitted when the fs.ReadStream is ready to be used.
Fires immediately after 'open'.

readStream.bytesRead#
Added in: v6.4.0
<number>
The number of bytes that have been read so far.

readStream.path#
Added in: v0.1.93
<string> | <Buffer>
The path to the file the stream is reading from as specified in the first argument to fs.createReadStream(). 
If path is passed as a string, then readStream.path will be a string. If path is passed as a Buffer, 
then readStream.path will be a Buffer.



        O
N               D
        E


Class: fs.Stats#
an object that provides info about a file 

fs.stat(), fs.lstat , fs.fstat() and sync counterparts return that class 

stats.isBlockDevice()#
Added in: v0.1.10
Returns: <boolean>
Returns true if the fs.Stats object describes a block device.

stats.isCharacterDevice()#
Added in: v0.1.10
Returns: <boolean>
Returns true if the fs.Stats object describes a character device.

stats.isDirectory()#
Added in: v0.1.10
Returns: <boolean>
Returns true if the fs.Stats object describes a file system directory.

stats.isFIFO()#
Added in: v0.1.10
Returns: <boolean>
Returns true if the fs.Stats object describes a first-in-first-out (FIFO) pipe.

stats.isFile()#
Added in: v0.1.10
Returns: <boolean>
Returns true if the fs.Stats object describes a regular file.

stats.isSocket()#
Added in: v0.1.10
Returns: <boolean>
Returns true if the fs.Stats object describes a socket.

stats.isSymbolicLink()#
Added in: v0.1.10
Returns: <boolean>
Returns true if the fs.Stats object describes a symbolic link.

This method is only valid when using fs.lstat().

stats.dev#
<number> | <bigint>
The numeric identifier of the device containing the file.

stats.ino#
<number> | <bigint>
The file system specific "Inode" number for the file.

stats.mode#
<number> | <bigint>
A bit-field describing the file type and mode.

stats.nlink#
<number> | <bigint>
The number of hard-links that exist for the file.

stats.uid#
<number> | <bigint>
The numeric user identifier of the user that owns the file (POSIX).

stats.gid#
<number> | <bigint>
The numeric group identifier of the group that owns the file (POSIX).

stats.rdev#
<number> | <bigint>
A numeric device identifier if the file is considered "special".

stats.size#
<number> | <bigint>
The size of the file in bytes.

stats.blksize#
<number> | <bigint>
The file system block size for i/o operations.

stats.blocks#
<number> | <bigint>
The number of blocks allocated for this file.

stats.atimeMs#
Added in: v8.1.0
<number> | <bigint>
The timestamp indicating the last time this file was accessed expressed in milliseconds since the POSIX Epoch.

stats.mtimeMs#
Added in: v8.1.0
<number> | <bigint>
The timestamp indicating the last time this file was modified expressed in milliseconds since the POSIX Epoch.

stats.ctimeMs#
Added in: v8.1.0
<number> | <bigint>
The timestamp indicating the last time the file status was changed expressed in milliseconds since the POSIX Epoch.

stats.birthtimeMs#
Added in: v8.1.0
<number> | <bigint>
The timestamp indicating the creation time of this file expressed in milliseconds since the POSIX Epoch.

stats.atime#
Added in: v0.11.13
<Date>
The timestamp indicating the last time this file was accessed.

stats.mtime#
Added in: v0.11.13
<Date>
The timestamp indicating the last time this file was modified.

stats.ctime#
Added in: v0.11.13
<Date>
The timestamp indicating the last time the file status was changed.

stats.birthtime#
Added in: v0.11.13
<Date>
The timestamp indicating the creation time of this file.


                                    
                                    O
                           
        
                            Stat Time Values
N                if you make a change to one time value on               D
                a file it will not change the other
                they are independent of each other 

                                    E


        O
N               D
        E

Class: fs.WriteStream#
Added in: v0.1.93
WriteStream is a Writable Stream.

Event: 'close'#
Added in: v0.1.93
Emitted when the WriteStream's underlying file descriptor has been closed.

Event: 'open'#
Added in: v0.1.93
fd <integer> Integer file descriptor used by the WriteStream.
Emitted when the WriteStream's file is opened.

Event: 'ready'#
Added in: v9.11.0
Emitted when the fs.WriteStream is ready to be used.
Fires immediately after 'open'.

writeStream.bytesWritten#
Added in: v0.4.7
The number of bytes written so far. Does not include data that is still queued for writing.

writeStream.path#
Added in: v0.1.93
The path to the file the stream is writing to as specified in the first argument to 
fs.createWriteStream(). If path is passed as a string, then writeStream.path will be a string.
 If path is passed as a Buffer, then writeStream.path will be a Buffer.


        O
N               D
        E



                                                                O
    
                    fs.access(path[, mode], callback)
                    
                    path <string> | <Buffer> | <URL>
                    mode <integer> Default: fs.constants.F_OK
                    callback <Function>
                        err <Error>
                    
                    it checks the permissions of a file. if there i
                    s an error there is a callback that handles it
                    the callback also handles no errors so
                    you can use it dynamically its inteneded to be used like this

                    The mode flag is used by the options in the  File Access Constants (see below)
                    see examples for conditional operators in the file
N                                                                                                                                  D
                    Using fs.access() to check for the accessibility of a
                    file before calling fs.open(), fs.readFile() or fs.writeFile() is not recommended
                    
                    In general, check for the accessibility of a file only if the file
                    will not be used directly, for example when its accessibility is a signal from another process.
                    
                    On Windows, access-control policies (ACLs) on a directory may
                    limit access to a file or directory. The fs.access() function,
                    bypasses that and gives you that file info

                    file: FS/fs_access.js

    
                                                                E



                                O



            fs.accessSync(path[, mode])
                                
 N          sync versiionn of fs.access
            If any of the accessibility checks fail,           D
            an Error will be thrown. Otherwise,
            the method will return undefined.
            file: FS/fs_access_sync.js


                                E


        O
N               D
        E


                                                    O
                                

                fs.appendFile(path, data[, options], callback)
                
                path <string> | <Buffer> | <URL> | <number> filename or file descriptor
                data <string> | <Buffer>
                options <Object> | <string>
                
                    encoding <string> | <null> Default: 'utf8'
                    mode <integer> Default: 0o666
                    flag <string> See support of file system flags. Default: 'a'.
                
                callback <Function>
N                                                                                                   D
                    err <Error>
                
                appends data to a file
                
                
                The path may be specified as a numeric file descriptor that has been opened
                for appending (using fs.open() or fs.openSync()).
                The file descriptor will not be closed automatically.

                If options is a string, then it specifies the encoding:
                fs.appendFile('message.txt', 'data to append', 'utf8', callback);
                
                use the fs.close function in the callback not outside because async runs at
                the same time which means it might close the file then the
                method appends to it and leaves it open
                file : FS/fs_appendFile.js


        O
N               find files that are open with a file descriptor with the lsof command
        E

                                                   E





                                                   O




                fs.appendFileSync(path, data[, options])

                path <string> | <Buffer> | <URL> | <number> filename or file descriptor
                data <string> | <Buffer>
                options <Object> | <string>

                    encoding <string> | <null> Default: 'utf8'
                    mode <integer> Default: 0o666
                    flag <string> See support of file system flags. Default: 'a'.
N                                                                                                   D

                sync version

                The path may be specified as a numeric file descriptor 
                that has been opened for appending (using fs.open() or fs.openSync()). 
                The file descriptor will not be closed automatically.

                file: FS/fs_appendFile_sync.js



                                                E




        O
N               D
        E





fs.chmod(path, mode, callback)

path <string> | <Buffer> | <URL>
mode <integer>
callback <Function>

    err <Error>

async file permission change the callback only takes an exception

File modes

a numneric bitmask argument created with a logical OR or this table 


+----------------------+-------+--------------------------+
| Constant             | Octal | Description              |
+----------------------+-------+--------------------------+
| fs.constants.S_IRUSR | 0o400 | read by owner            |
+----------------------+-------+--------------------------+
| fs.constants.S_IWUSR | 0o200 | write by owner           |
+----------------------+-------+--------------------------+
| fs.constants.S_IXUSR | 0o100 | execute/search by owner  |
+----------------------+-------+--------------------------+
| fs.constants.S_IRGRP | 0o40  | read by group            |
+----------------------+-------+--------------------------+
| fs.constants.S_IWGRP | 0o20  | write by group           |
+----------------------+-------+--------------------------+
| fs.constants.S_IXGRP | 0o10  | execute/search by group  |
+----------------------+-------+--------------------------+
| fs.constants.S_IROTH | 0o4   | read by others           |
+----------------------+-------+--------------------------+
| fs.constants.S_IWOTH | 0o2   | write by others          |
+----------------------+-------+--------------------------+
| fs.constants.S_IXOTH | 0o1   | execute/search by others |
+----------------------+-------+--------------------------+


its better to do it like this , they will be applied like so

0o765 means
owner can read write and execute
group can read and write 
others can read and execute 

on windows on write permission can be changed , and there is no usr grp oth distinction 

+--------+------------------------+
| Number | Description            |
+--------+------------------------+
| 7      | read write and execute |
+--------+------------------------+
| 6      | read and write         |
+--------+------------------------+
| 5      | read and execute       |
+--------+------------------------+
| 4      | read only              |
+--------+------------------------+
| 3      | write and execute      |
+--------+------------------------+
| 2      | write only             |
+--------+------------------------+
| 1      | execute only           |
+--------+------------------------+
| 0      | no permission          |
+--------+------------------------+    


fs.chmodSync(path, mode)

path <string> | <Buffer> | <URL>
mode <integer>

sync version of fs.chmod




        O
N               D
        E

fs.chown(path, uid, gid, callback)
fs.chownSync(path, uid, gid)
History
path <string> | <Buffer> | <URL>
uid <integer>
gid <integer>
callback <Function>

    err <Error>

    changes the owner and group of a file 




        O
N               D
        E


                                                O

                fs.close(fd, callback)
                fs.closeSync(fd)

                fd <integer>
                callback <Function>

                    err <Error>

N                                                                               D                                                    
                async file close with fd as file descriptor 
                and the error arg the only arg for a callback 
                sync returns undefined


                                                E







        O
N               D
        E


                                                    O

                fs.copyFile(src, dest[, flags], callback)
                fs.copyFileSync(src, dest[, flags])
                Added in: v8.5.0

                src <string> | <Buffer> | <URL> source filename to copy
                dest <string> | <Buffer> | <URL> destination filename of the copy operation
                flags <number> modifiers for copy operation. Default: 0.
                    callback <Function>

                async copy src -> dest, callback only takes error arg, if something foes wrong after opening  
                the destination for writing Node.js will attempt to close the  file
N                                                                                                                               D
                flags in an interger telling the method how to copy

                fs.constants.COPYFILE_EXCL - The copy operation will fail if dest already exists. 
                                                with no flags the dest is overwritten
                                               so if you want to overwrite your destination leave it out
                fs.constants.COPYFILE_FICLONE - The copy operation will attempt to create a copy-on-write reflink.
                                                 If the platform does not support copy-on-write, then a
                                                 fallback copy mechanism is used.                                 
                fs.constants.COPYFILE_FICLONE_FORCE - The copy operation will attempt to create a 
                                                        copy-on-write reflink. If the platform does not support
                                                         copy-on-write,
                                                         then the operation will fail.
                file: FS/copyFile.js       

                to use the flags get the flag 
                const { COPYFILE_EXCL } = fs.constants;

                and do this 
                fs.copyFile('source.txt', 'destination.txt', COPYFILE_EXCL, callback);
                file: FS/copyFile_flag.js



                                                    E



        O                                                
N           if you want  to import a property from an object in a module  
            const { [property_name] } = [module_name].[object_name];
        E                                                 





                                            O

                fs.createReadStream(path[, options])

                path <string> | <Buffer> | <URL>
                options <string> | <Object>

                    flags <string> See support of file system flags.
                     Default: 'r'.
                    encoding <string> Default: null
                    fd <integer> Default: null                                        
                    mode <integer> Default: 0o666
                    autoClose <boolean> Default: true
                    start <integer>
                    end <integer> Default: Infinity
                    highWaterMark <integer> Default: 64 * 1024
N                                                                                             D
                USUAL highWaterMark of  readable streams = 16 kb  ,
                  this method  highWaterMark = 64 kb

                options     
                start and end can be int to read a range of bytes instead of the entire file 
                    they are both inclusive and start at 0 
                     The encoding can be any one of those accepted by Buffer.
                     if fd is specified this  method will use it and ignore the path 
                     becuase the file is open 
                     if fd point s to a character device that only supports blocking reads
                      (such as keyboard or sound card )
                     read operations do not finish until data is available , 
                     this can prevent the process from closing the stream
                     and exiting naturally 
                     file:FS/readStream.js 

                     if autoClose is false then the fd wont be closed even on 'error' 
                        the default is true and it will close on error or 'end '

                      mode sets file permission and sticky bits only if the file was created 
                      if options is a string it specifies encoding   


                                            E   







                                            O



                fs.createWriteStream(path[, options])  

                path <string> | <Buffer> | <URL>
                options <string> | <Object>

                    flags <string> See support of file system flags.
                     Default: 'r'.
                    encoding <string> Default: null
                    fd <integer> Default: null                                        
                    mode <integer> Default: 0o666
                    autoClose <boolean> Default: true
                    start <integer>
                    end <integer> Default: Infinity    

N                                                                                                       D
                options     
                start and end can be int to read a range of bytes instead of the entire file 
                    they are both inclusive and start at 0 
                     The encoding can be any one of those accepted by Buffer.
                     if fd is specified this  method will use it and ignore the path 
                     becuase the file is open 
                     non-blocking fd will be sent to net.Socket 
                     read operations do not finish until data is available , 
                     this can prevent the process from closing the stream
                     and exiting naturally                      

                     if autoClose is false then the fd wont be closed even on 'error' 
                        the default is true and it will close on error or 'finish' 

                      mode sets file permission and sticky bits only if the file was created 
                      if options is a string it specifies encoding    

                                             E                      



        O
N            fs.exists(path, callback)  Deprecated: Use fs.stat() or fs.access() instead.
                fs.existsSync(path) IS NOT deprecated  
             Returns true if the path exists, false otherwise.
        E                                                                                                       




        O
N               D
        E

fchmod and fchown are just like chmod & chown but they take the file descriptor instead of the file 
fs.fchmod(fd, mode, callback)[src]#
fs.fchmodSync(fd, mode)
History
fd <integer>
mode <integer>
callback <Function>

    err <Error>
fchmod(2).ONLY error arg for completion callback.




fs.fchown(fd, uid, gid, callback)[src]#
fs.fchownSync(fd, uid, gid)
History
fd <integer>
uid <integer>
gid <integer>
callback <Function>

    err <Error>
Asynchronous fchown(2). ONLY error arg for completion callback.
sync returns undefined 






        O
N               D
        E

                                                                    O



                datasync is a method that flushes the file to permeant storage in case the system crashes or reboots 
                however it keeps metadata needed for data recovery at system reboot such as the file size, and its tosses
                unessary metadata for recovery such as a_time and c_time. sync keeps everything including metadata 

                fs.fdatasync(fd, callback)[src]#
                fs.fdatasyncSync(fd)
                History
                fd <integer>
                callback <Function>

                    err <Error>
                Async fdatasync(2). ONLY error arg for completion callback.
                sync fdatasync(2). Returns undefined.


N                                                                                                                       D
                fs.fsync(fd, callback)[src]#
                fs.fsyncSync(fd)
                History
                fd <integer>
                callback <Function>

                    err <Error>
                Async fsync(2). ONLY error arg for completion callback.
                sync returns undefined



                                                                    E



        O
N               D
        E





                                    O

        fs.fstat(fd[, options], callback)
        fs.fstatSync(fd[, options])
        History
        fd <integer>
        options <Object>

        bigint <boolean> Whether the numeric values in the returned
         fs.Stats object should be bigint. Default: false.
        callback <Function>

        err <Error>
        stats <fs.Stats>
        Asynchronous fstat(2). The callback gets two arguments 
        (err, stats) where stats is an fs.Stats object. 
        fstat() is identical to stat(), except that the 
        file to be stat-ed is specified by the file descriptor fd.
        sync version retunrs  <fs.Stats>
N                                                                            D
        


                                E





        O
N               D
        E



                                                        O


                fs.ftruncate(fd[, len], callback)[src]#
                fs.ftruncateSync(fd[, len])
                v0.8.6
                History
                fd <integer>
                len <integer> Default: 0
                callback <Function>

                    err <Error>

                async ftruncate .
                sync Returns undefined.

                IF the file assoc  with fd is largen then len the first len bytes will be kept 
                file: FS/truncate_plus.js
 N              IF the fd file is shorter than len. its extended and  filled up with null bytes    D
                ('\0'):
                on ubuntu 16.04.5  you see ^@   
                file: FS/truncate_minus.js 




                                                    E


        O
N               D
        E


fs.futimes(fd, atime, mtime, callback)
fs.futimesSync(fd, atime, mtime)
fd <integer>
atime <number> | <string> | <Date>
mtime <number> | <string> | <Date>
callback <Function>

    err <Error>

refer to fs.utimes to  see what it does 
ASYNC 
This function does not work on AIX versions before 7.1,
 it will return the error UV_ENOSYS








        O
N               D
        E


when you see l from chmod or chown this means it takes the path of the file but does not follow symbolic links 
fs.lchmod(path, mode, callback)

fs.lchmodSync(path, mode)
Deprecated since: v0.4.7

path <string> | <Buffer> | <URL>
mode <integer>
callback <Function>

    err <Error>
Asynchronous lchmod(2). only err for callback


        O
N               Only available on macOS.
        E



fs.lchown(path, uid, gid, callback)[src]#
fs.lchownSync(path, uid, gid)
History
path <string> | <Buffer> | <URL>
uid <integer>
gid <integer>
callback <Function>
    err <Error>
Asynchronous lchown(2). only err for callback
sync returns undefined


fs.lstat(path[, options], callback)[src]#
fs.lstatSync(path[, options])
History
path <string> | <Buffer> | <URL>
options <Object>

bigint <boolean> Whether the numeric values in the returned fs.Stats object should be bigint. Default: false.
callback <Function>

    err <Error>
    stats <fs.Stats>
Asynchronous lstat(2). The callback gets two arguments (err, stats) where stats is a
 fs.Stats object. lstat() is identical to stat(), except that if 
 path is a symbolic link, then the link itself is stat-ed, not the file that it refers to.
 sync reuturns <fs.Stats> 




        O
N               D
        E


link makes a hard link between two paths 

fs.link(existingPath, newPath, callback)[src]#
fs.linkSync(existingPath, newPath)
History
existingPath <string> | <Buffer> | <URL>
newPath <string> | <Buffer> | <URL>
callback <Function>

    err <Error>
Asynchronous link(2). No arguments other than a 
possible exception are given to the completion callback.
sync reutns undefined


        O
N               D
        E


                                                O


                fs.mkdir(path[, options], callback)
                fs.mkdirSync(path[, options])

                path <string> | <Buffer> | <URL>
                options <Object> | <integer>

                    recursive <boolean> Default: false
                    mode <integer> Not supported on Windows. Default: 0o777.
                callback <Function>

                    err <Error>
N                                                                                        D
                only error arg given to callback completion 
                options can be an interger making dir permissions, 
                or an object containing mode with integers
                if recursive is true directory is created even 
                    if anything in the paths does  not exist, 
                if false directories are not created if parents do not exist

                file FS/mkdir.js     


                                                E



fs.mkdtemp(prefix[, options], callback)
fs.mkdtempSync(prefix[, options])
prefix <string>
options <string> | <Object>

    encoding <string> Default: 'utf8'
callback <Function>

    err <Error>
    folder <string>

creates a unique temp dir when six random chars are appeneded to a prefix to create a unique dir 
The created folder path is passed as a string to the callback's second parameter.


        O
N               when the tmpdir is created is dir mode is 700
        E


        O
N               D
        E

fs.open(path, flags[, mode], callback)
fs.openSync(path, flags[, mode])

path <string> | <Buffer> | <URL>
flags <string> | <number> 
mode <integer> Default: 0o666 (readable and writable)
callback <Function>

    err <Error>
    fd <integer>

flags a,w,r,s,x,+ open the file for certain support 
    mode: sets file permissions 
Functions based on fs.open() exhibit this behavior as well: fs.writeFile(), fs.readFile(), 



        O
N               D
        E

                                                O


            What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` "unsafe"?#
            When calling Buffer.allocUnsafe() and Buffer.allocUnsafeSlow(), the segment 
            of allocated memory is uninitialized (it is not zeroed-out). While this
             design makes the allocation of memory quite fast, the allocated segment 
             of memory might contain old data that is potentially sensitive. Using a 
             Buffer created by Buffer.allocUnsafe() without completely overwriting the 
             memory can allow this old data to be leaked when the Buffer memory is read.
N                                                                                                                       D

            While there are clear performance advantages to using Buffer.allocUnsafe(), 
            extra care must be taken in order to avoid introducing security vulnerabilities
             into an application.


                                                E



                                                O
                        need to read from a buffer 


                        const buf3 = Buffer.from(<Buffer 88 13 70 17>);

                        const buf1 = Buffer.from('this is a tést');
                        const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');

                        const buf = Buffer.from(new String('this is a test'));

                        
                        Class Method: Buffer.alloc(size[, fill[, encoding]])
                        History
                        size <integer> The desired length of the new Buffer.
                        fill <string> | <Buffer> | <integer> A value to pre-fill
                        the new Buffer with. Default: 0.
                        encoding <string> If fill is a string, 
                        this is its encoding. Default: 'utf8'.


                        need to write data to a buffer ?
                        const buf = Buffer.alloc(5);

                        need to fill a buffer 
                        const buf = Buffer.alloc(5, 'a');
N                       const buf = Buffer.alloc(5, 1);                                                      D
                        const buf = Buffer.alloc(5, Buffer.from(data));         

                        need to specify encoding 

                        const buf = Buffer.alloc(5, 'a', 'utf8');  //default 


                        Class Method: Buffer.allocUnsafe(size)
                        if you need performance and got security in place 
                        const buf = Buffer.allocUnsafe(10);

                        console.log(buf);
                        // Prints: (contents may vary): <Buffer a0 8b 28 3f 01 00 00 00 50 32>    
                        refer to article at top of tutorial to learn how to keep node processes under 300 MB 
                        to free mem alloc by a buf 
                        buf = null
                        all_references = null
                        also use process.memoryUsage(). to identify if its works, 
                        if it doesnt grow you should be fine 


                                                E                                   




        O
N               D
        E


                                        O

            fs.read(fd, buffer, offset, length, position, callback)
            fs.readSync(fd, buffer, offset, length, position)

            fd <integer>
            buffer <Buffer> | <TypedArray> | <DataView>
            offset <integer>
            length <integer>
            position <integer>
            callback <Function>

                err <Error>
                bytesRead <integer>
                buffer <Buffer>


            Read data from the file specified by fd.

            buffer is the buffer that the data will be written to.

            offset is the offset in the buffer to start writing at.
N                                                                                             D
            length is an integer specifying the number of bytes to read.

            position is an argument specifying where to begin reading from in the file.
             If position is null, data will be read from the current file position, 
             and the file position will be updated. If position is an integer, 
             the file position will remain unchanged. make sure position is there man 


            The callback is given the three arguments, (err, bytesRead, buffer).

            If this method is invoked as its util.promisify()ed version, 
            it returns a Promise for an Object with bytesRead and buffer properties.
            file: FS/read.js

        O           
N            If the file bytes amount is less than length it will still read the file no problem 
        E     

                                                    E








                                                    O

                            fs.readdir(path[, options], callback)
                            fs.readdirSync(path[, options])

                            path <string> | <Buffer> | <URL>
                            options <string> | <Object>

                                encoding <string> Default: 'utf8'
                                withFileTypes <boolean> Default: false
                            callback <Function>
N                                                                                                       D
                                err <Error>
                                files <string[]> | <Buffer[]> | <fs.Dirent[]>                                                    

                            read dir contents, callback gets a files listung the files in the dir excluding . & ..
                            if options is a string it specifies encoding, if encoding : buffer the files will be buffer objects  
                            withFileTypes = true, files return fs.Dirent objects 

                            file: FS/readdir.js

                                                    E





                                                    O

                    fs.readFile(path[, options], callback)
                    fs.readFileSync(path[, options])
                    path <string> | <Buffer> | <URL> | <integer> filename or file descriptor
                    options <Object> | <string>

                        encoding <string> | <null> Default: null
                        flag <string> See support of file system flags. Default: 'r'.
                    callback <Function>

                        err <Error>
                        data <string> | <Buffer>

N                                                                                                    D
                    async file read
                    callback err, data data is the content of the file
                    if object is a string specifies encoding 
                    make sure mode is read-friendly :)
                    if the path is a directory on Linux Windows and 
                    Mac its an error on FreeBSD it gives you something 

                    the fs readfile buffers the whole files,
                     try to use fs.createReadStream in production

                    if you use a fd
                    it has to support reading 
                    its not closed automatically
                    if there was an fs.read or fs.write it will begin at where those 
                    function that are  pos friendly left off 

                    file: FS/read_fd.js


                                                    E



                            O

                fs.readlink(path[, options], callback)
                fs.readlinkSync(path[, options])
                path <string> | <Buffer> | <URL>
                options <string> | <Object>

                    encoding <string> 'utf8' || 'buffer'
                callback <Function>
N                                                           D
                    err <Error>
                    linkString <string> | <Buffer>

                reads a symbolic link
                file: FS/readlink.js 

                            E



        O
N               D
        E


                                                O

                    fs.realpath(path[, options], callback) 
                    fs.realpathSync(path[, options])
                    path <string> | <Buffer> | <URL>
                    options <string> | <Object>

                        encoding <string> Default: 'utf8'
                    callback <Function>

                        err <Error>
                        resolvedPath <string> | <Buffer>
N                                                                                           D
                    Async computes the canonical absolute pathname of a file     
                    it doesn't do case conversion
                    max # of symbolic links is much high than native realpath 

                    only UTF8-convertible paths are supported 
                    May use process.cwd to resolve relative paths callback gets err, resolvedPath

                    if path goes to a socket or pipe the function will return a system dependent name for it 

                    file FS/real_path.js 



                                               E





                                               O

                fs.realpath.native(path[, options], callback)
                fs.realpathSync.native(path[, options])
                path <string> | <Buffer> | <URL>
                options <string> | <Object>

                    encoding <string>  'utf8' || 'buffer '
                callback <Function>
N                                                                                     D
                    err <Error>
                    resolvedPath <string> | <Buffer>                                               




                On Linux, when Node.js is linked against musl libc, 
                the procfs file system must be mounted on /proc in order 
                for this function to work. Glibc does not have this restriction.

                                            E


        O
N               D
        E

fs.rename(oldPath, newPath, callback)
fs.renameSync(oldPath, newPath)
oldPath <string> | <Buffer> | <URL>
newPath <string> | <Buffer> | <URL>
callback <Function>

    err <Error>

rename a file, if newPath exists it will be overwritten 

        O
N               D
        E


fs.rmdir(path, callback)
fs.rmdirSync(path)
path <string> | <Buffer> | <URL>
callback <Function>

    err <Error>

rmdir 
if rm a file with this 
    Windows: error.code = ENOENT
    POSIX: error.code = ENOTDIR 



        O
N               D
        E



fs.stat(path[, options], callback)
fs.statSync(path[, options])

path <string> | <Buffer> | <URL>
options <Object>

    bigint <boolean> Whether the numeric values in the returned fs.Stats object should be bigint. Default: false.
callback <Function>

    err <Error>
    stats <fs.Stats>

info about a file 
possible error codes, Common SystemError see above in errors 
dont use to test for the existence of a a file before fs.open 

In linux 16.04.5 the a,c,m, and birth time(Ms)? are reported wrong notify the developer about this 


        O
N               D
        E

fs.symlink(target, path[, type], callback)
fs.symlinkSync(target, path[, type])

target <string> | <Buffer> | <URL>
path <string> | <Buffer> | <URL>
type <string> Default: 'file'
callback <Function>

    err <Error>

make a symlink for the target in path 
for type only  on Windows there is  dir file and junction, abs path are forced for junction
file: FS/unlink.js  // yes its unlink.js trust me  




        O
N               D
        E

fs.truncate(path[, len], callback) 
fs.truncateSync(path[, len])    

path <string> | <Buffer> | <URL>
len <integer> Default: 0
callback <Function>

    err <Error>

dont use fd here use ftruncate (see aboove)    
(see above also for how truncate works)


        O
N               D
        E

fs.unlink(path, callback)
fs.unlinkSync(path)


path <string> | <Buffer> | <URL>
callback <Function>
    err <Error>

Async removes a file or symbolic link use this to rm a file 
file : FS/unlink.js 


        O
N               D
        E
fs.unwatchFile(filename[, listener])

filename <string> | <Buffer> | <URL>
listener <Function> Optional, a listener previously attached using fs.watchFile()        

if a file is not being watch theres a no-op
using fs.watch is more efficient 

        O
N          no-op are when no operations are performed but it takes up small space don't do no-op they add up'      
        E





        O
N               D
        E

fs.utimes(path, atime, mtime, callback)
fs.utimesSync(path, atime, mtime)
path <string> | <Buffer> | <URL>
atime <number> | <string> | <Date>
mtime <number> | <string> | <Date>
callback <Function>

    err <Error>


changing fs timestamps
Values can be either numbers representing 
Unix epoch time, Dates, or a numeric string like '123456789.0'.
If the value can not be converted to a number, 
or is NaN, Infinity or -Infinity, an Error will be thrown.




        O
N               D
        E


fs.watch(filename[, options][, listener])

filename <string> | <Buffer> | <URL>
options <string> | <Object>

    persistent <boolean> Indicates whether the process should continue to
                         run as long as files are being watched. Default: true.
    recursive <boolean> Indicates whether all subdirectories should be watched, 
                        or only the current directory.
                         This applies when a directory is specified,
                          and  only supported on macOS and Windows..
                           might need inotify to get it to work on 16.04 or 18.04 Default: false.
    encoding <string> Specifies the character encoding to be used for the filename passed to the listener. Default: 'utf8'.
listener <Function> | <undefined> Default: undefined

    eventType <string>
    filename <string> | <Buffer>

returns a fs.Watcher object 

watches for chanages on filename = file | dir 
optios a string or object  
eventType is 'rename' || 'change', rename might be differnt on linux 
filename  = filename.trigger('watch') 
The listener callback is attached to the 'change' event fired by fs.FSWatcher,
 but it is not the same  as the 'change' value of eventType.


                                            O

         Availability#

         you need for fs.watch to work 
         On Linux systems, this uses inotify(7).
        On BSD systems, this uses kqueue(2).
N        On macOS, this uses kqueue(2) for files and FSEvents for directories.         D
        On SunOS systems (including Solaris and SmartOS), this uses event ports.
        On Windows systems, this feature depends on ReadDirectoryChangesW.
        On Aix systems, this feature depends on AHAFS, which must be enabled.


or use fs.watchFile (slower)
                                        E





                                        O
Inodes

        on Linux and MacOS, when files get deleted and recreated they get new inodes, fs.watch
         watches the orginal inode still its supposed to be like this, close and recall fs.watch
         to hopefully get the new inode 
N                                                                                                    D
        AIX system keep the inode no matter 
        so you will start to get 2 notificatiosn for new content and truncation

                                        E



                                        O

            Filename Argument

N                                                                    D
             Linux, macOS, Windows, and AIX supported ,
              but fs.watch  may always not get the file and thats it                                 

                                        E






                                                O


            Class: fs.FSWatcher
            an object that emits a change event when ever a file is modified 

            Event: 'change'
            eventType <string> The type of change event that has occurred
            filename <string> | <Buffer> The filename that changed (if relevant/available)

            depending on OS filename may not be provided , 
             if encoding set to buffer fs.watch will print 
            the filename as a buffer 
                    O 
            N             it catches the first chage but not subsquent changes
                    D
            File: FS/fs_watch.js        

N                                                                                                       D

            Event: 'close'#
            Added in: v10.0.0
            Emitted when the watcher stops watching for changes.
             The closed fs.FSWatcher object is no longer usable in the event handler.


             Event: 'error'#
            Added in: v0.5.8
            error <Error>
            Emitted when an error occurs while watching the file. 
            The errored fs.FSWatcher object is no longer usable in the event handler.

            watcher.close()#
            Added in: v0.5.8
            Stop watching for changes on the given fs.FSWatcher. 
            Once stopped, the fs.FSWatcher object is no longer usable.


                                                    E



fs.watchFile(filename[, options], listener)
filename <string> | <Buffer> | <URL>
options <Object>

    persistent <boolean> Default: true
    interval <integer> Default: 5007
listener <Function>

    current <fs.Stats>
    previous <fs.Stats>

options
    interval, interval in ms on how many times filename is polled 

if it results in an err.code = ENOENT , the curr and prev fs.Watchers should have 0's or EPOCH'S for their fields 
if a file disappears and reapears the prev in the sencond will be the same as prev in the first         


        O
N               D
        E


                                            O


            fs.write(fd, buffer[, offset[, length[, position]]], callback)
            fs.writeSync(fd, buffer[, offset[, length[, position]]])
            fs.write(fd, string[, position[, encoding]], callback)  
            fs.writeSync(fd, string[, position[, encoding]])      


            fd <integer>
            buffer <Buffer> | <TypedArray> | <DataView>
            offset <integer>
            length <integer>
            position <integer>
            callback <Function>

                err <Error>
                bytesWritten <integer>
                buffer <Buffer> | <TypedArray> | <DataView>



            string <string>
            position <integer>
            encoding <string> 'utf8' | 
            callback <Function>
N                                                                               D
                err <Error>
                written <integer>
                string <string>    



            in Linux on append mode, positional write do not work 
            the kernel always appends data to the end of the file 

            always using a number for positioning 

            offset represents where to start writing from the buffer 
            lenght how much should be written 
            position is where in the file to start wrtitng 
            encoding is how the string should end up, 
            callback
                bytesWritten is not the same as writen 
                bytesWritten is for bytes writen  is for chars



                    O      
            N         as you see when buffer is used you specify length, but when string 
                        is used you must write all the data so if you want to be 
                      nit picky its gunna take extra work with those buffers    
                    E

            file: FS/write.js    

                                                    E





                                                    O


                fs.writeFile(file, data[, options], callback)
                fs.writeFileSync(file, data[, options])

                file <string> | <Buffer> | <URL> | <integer> filename or file descriptor
                data <string> | <Buffer> | <TypedArray> | <DataView>
                options <Object> | <string>

                    encoding <string> | <null> Default: 'utf8'
                    mode <integer> Default: 0o666
                    flag <string> See support of file system flags. Default: 'w'.
                callback <Function>
N                                                                                                    D
                    err <Error>

                if data is a buffer encoding is ignored
                use fs.createWriteStream() for multiple callbacks 

                fd

                it must suport writing not appending 
                it will not be closed automattically 
                the writing would being at the beginning, 
                Ex 
                    file.content = 'Hello Word'
                    data = 'aloha '
                    file.content = 'aloha  Word'


                                                    E



        O
N               D
        E


fs Promises API#
Stability: 1 - Experimental
The fs.promises API provides an alternative set of asynchronous file system methods that 
return Promise objects rather than using callbacks. The API is accessible via require('fs').promises.    

i dont have time for Experimental in production




        O
N               D
        E

FS Constants
not every constant is available on every OS 


File Access Constant
fs.access().


|----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Constant | Description                                                                                                                                                                                   |
|----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| F_OK     | Flag indicating that the file is visible to the calling process. 
            =This is useful for determining if a file exists but says nothing about rwx permissions
            .= Default if no mode is specified." 
|----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| R_OK     | Flag indicating that the file can be read by the calling process.                                                                                                                             |
|----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| W_OK     | Flag indicating that the file can be written by the calling process.                                                                                                                          |
|----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| X_OK     | Flag indicating that the file can be executed by the calling process.
             This has no effect on Windows (will behave like fs.constants.F_OK).                                                     |
|----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|



File COpy constant 
fs.copyFile().


|------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Constant               | Description                                                                                                                                                                          |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| COPYFILE_EXCL          | "If present the copy operation will fail with an error if the destination path already exists."                                                                                      |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| COPYFILE_FICLONE       | "If present the copy operation will attempt to create a copy-on-write reflink. 
                            If the underlying platform does not support copy-on-write then a fallback copy mechanism is used."    |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| COPYFILE_FICLONE_FORCE | "If presentthe copy operation will attempt to create a copy-on-write reflink. 
                            If the underlying platform does not support copy-on-write then the operation will fail with an error." |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                        |                                                                                                                                                                                      |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|


File Open Constants
Constant,Description
O_RDONLY,Flag indicating to open a file for read-only access.
O_WRONLY,Flag indicating to open a file for write-only access.
O_RDWR,Flag indicating to open a file for read-write access.
O_CREAT,Flag indicating to create the file if it does not already exist.
O_EXCL,Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists.
O_NOCTTY,"Flag indicating that if path identifies a terminal device, 
        opening the path shall not cause that terminal to become the controlling terminal 
        for the process (if the process does not already have one)."
O_TRUNC,"Flag indicating that if the file exists and is a regular file, 
         and the file is opened successfully for write access, its length shall be truncated to zero."
O_APPEND,Flag indicating that data will be appended to the end of the file.
O_DIRECTORY,Flag indicating that the open should fail if the path is not a directory.
O_NOATIME,Flag indicating reading accesses to the file system will no longer
         result in an update to the atime information associated with the file. 
            This flag is available on Linux operating systems only.
O_NOFOLLOW,Flag indicating that the open should fail if the path is a symbolic link.
O_SYNC,Flag indicating that the file is opened for synchronized I/O with write operations waiting for file integrity.
O_DSYNC,Flag indicating that the file is opened for synchronized I/O with write operations waiting for data integrity.
O_SYMLINK,Flag indicating to open the symbolic link itself rather than the resource it is pointing to.
O_DIRECT,"When set, an attempt will be made to minimize caching effects of file I/O."
O_NONBLOCK,Flag indicating to open the file in nonblocking mode when possible.



File Type Constants 
fs.stat object 
Constant,Description
S_IFMT,Bit mask used to extract the file type code.
S_IFREG,File type constant for a regular file.
S_IFDIR,File type constant for a directory.
S_IFCHR,File type constant for a character-oriented device file.
S_IFBLK,File type constant for a block-oriented device file.
S_IFIFO,File type constant for a FIFO/pipe.
S_IFLNK,File type constant for a symbolic link.
S_IFSOCK,File type constant for a socket.


File Mode Constants
Constant,Description
S_IRWXU,"File mode indicating readable, writable, and executable by owner."
S_IRUSR,File mode indicating readable by owner.
S_IWUSR,File mode indicating writable by owner.
S_IXUSR,File mode indicating executable by owner.
S_IRWXG,"File mode indicating readable, writable, and executable by group."
S_IRGRP,File mode indicating readable by group.
S_IWGRP,File mode indicating writable by group.
S_IXGRP,File mode indicating executable by group.
S_IRWXO,"File mode indicating readable, writable, and executable by others."
S_IROTH,File mode indicating readable by others.
S_IWOTH,File mode indicating writable by others.
S_IXOTH,File mode indicating executable by others.


        O
N               D
        E
File System Flags 
'a' - Open file for appending. The file is created if it does not exist.

'ax' - Like 'a' but fails if the path exists.

'a+' - Open file for reading and appending. The file is created if it does not exist.

'ax+' - Like 'a+' but fails if the path exists.

'as' - Open file for appending in synchronous mode. The file is created if it does not exist.

'as+' - Open file for reading and appending in synchronous mode. The file is created if it does not exist.

'r' - Open file for reading. An exception occurs if the file does not exist.

'r+' - Open file for reading and writing. An exception occurs if the file does not exist.

'rs+' - Open file for reading and writing in synchronous mode. 
Instructs the operating system to bypass the local file system cache.

This is primarily useful for opening files on NFS mounts as 
it allows skipping the potentially stale local cache.
 It has a very real impact on I/O performance so using this flag is not recommended unless it is needed.

 if you want sync open us fs.openSync 

'w' - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).

'wx' - Like 'w' but fails if the path exists.

'w+' - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).

'wx+' - Like 'w+' but fails if the path exists.


flag can  be  a number also 
On Windows constants are translated to their equivalents

the exclusinve flage 'x' ensures new path creation.
on POSIX the path exists even if its symlinked to non-existent file 
it might or might not work ont network file systems 

on linux positional writes do not work on append  mode it always writes to the end of the file 

use r+ to modify a file use w to delete it 

in linux and MacOS open a dir with a+ is an Error
    on Windows and FreeBSD its returns null or a FileHandle

on Windows open hiddn files with the r+ flag 

call fs.ftruncate()  to reset file contents     


        <OBJECT></OBJECT>
N               D
        E
What I take away from the fs api
fd are important and there are fd functions for every function try to look for it
    if the description says it ok its ok then  
to keep peace with  your system         
    always make sure your files are closed
    always make sure you do things in async in production 
    free buffers and be careful with the mathemathics software w/ buffers 
every callback should take at least an error you must check for 
you are handling system files, make sure they are right and if not make sure you use ftruncate()
    but if you run the program it may be too late 
avoid using promises, they are unstable        




need to learn about  streams and buffers mabye (try to avoid)  and fs.util 




        O
N               D
        E
Node Events API 

        O
N               be careful yoo might get slightly different things according to yor OS
        E



                                                O
            
        how Events work is that you have a eventEmitter class, it gets an action and/or emits an event and you 
        have these function objects (listeneres) called everytime the event is emitted .

        all functions attached to a specific event are sync called. 
N                                                                                                           D
                O
        N        any values returned from listenerens are ignored and discarded
                E

        eventEmitter.on() is used to register listneners  can also use  emitter.addListener(eventName, listener)
        eventEmitter.emit() is used to trigger events just like jquery.trigger([event])   

        file EVENTS/basic_eventemitter.js      


                                                E

emitter.on(eventName, listener)
emitter.addListener(eventName, listener)
emitter.prependListener(eventName, listener);

Added in: v0.1.101
eventName <string> | <symbol> The name of the event.
listener <Function> The callback function
Returns: <EventEmitter>
    no check is made to see if the listener is added, yuo have function below to do that     
    use prependListener to prepend a listener to the beginning of a stack                                         





emitter.emit(eventName[, ...args])
returns boolean if event had listeners 
args provides args for all listeners idk how they work for multiple listneners

                                                O



        if you want arguments for .emit you must provide arguments
         in the callback for . on (if theres is one callback)
         the this argument, comes free (no need to declare) and 
N         refers to your eventEmitter object                                                D
         if you use the ES6 arrow instance you will not will not get this at all 
        so just use the name of your ee object    
        file: EVENTS/eemiter_args.js 


                                            E


to get listenenrs to be called async use 
    setImmediate() or process.nextTick()  
    file: EVENTS/async_listener_call.js 



to listen for an event once  
    emitter.once(eventName, listener)#
    emitter.prependOnceListener(eventName, listener);
    Added in: v0.3.0
    eventName <string> | <symbol> The name of the event.
    listener <Function> The callback function
    Returns: <EventEmitter>
        after it gets the event no more listener
        use prependOnceListener to prepend to the beginning of the once stack  

file: EVENTS/once.js

if you wanted to handle errors use the error listener 
file:     EVENTS/errors.js




        O
N               D
        E
Class: EventEmitter
new listener : emit 'newListener'
remove listerer : removeListener

                                            O

        Event: 'newListener'

        eventName <string> | <symbol> The name of the event being listened for
        listener <Function> The event handler function

N                                                                                                   D
        so if you add an event listener with the same event name as one after the newListener
        the one inside the newListener listener will be added before the one outside 

        the listner returns the actual listnener function object 

        FILE : FS/new_listener.js 


                                                E




                                                O
                Event: 'removeListener'

                eventName <string> | <symbol> The event name
                listener <Function> The event handler function  
N                                                                                   D
                listenes for removed events          
                FS/new_listener.js                                      


                                                E



                                                O

                EventEmitter.defaultMaxListeners

                tells you how many listeners can be registed for a single event 10
                if you set this to  negative a type error is thrown 

                if you change this it affects the  EventEmitter instances before the change 
                look at emitter.setMaxListeners() to bypass this problem 
                but the  EventEmitter will send warnings to stderr for memory leaks 
N                                                                                                   D

                you can use --trace-warnings to get a stack trace for those warnings

                you can also use process.on('warning') to get detailed information about ee 
                causing the specific warnig  

                file  EVETNS/ee_def_max.js


                                                E



                                                


emitter.eventNames()
returns array of all listneners registered with ee instance 

emitter.getMaxListeners()
return default EventEmitter.defaultMaxListeners
returns max listeners allowed for ee instance 


emitter.listenerCount(eventName)
Added in: v3.2.0
eventName <string> | <symbol> The name of the event being listened for
Returns: <integer>

    how many listeners on the event for the ee instance 


emitter.listeners(eventName)
eventName <string> | <symbol>
Returns: <Function[]>

unlike what newListener and removeListener it gives you only [ [Function] ]



                                        O

                emitter.removeAllListeners([eventName])
                Added in: v0.1.26
                eventName <string> | <symbol>
 N              Returns: <EventEmitter>
                    Removes all listeners, or those                D
                    of the specified eventName.

                try not to use with with common events, use it
                 with very custom events or check all 
                 the modules or dont use it 

                                        E








                                                            O

            emitter.removeListener(eventName, listener)
            emitter.off(eventName, listener)

            eventName <string> | <symbol>
            listener <Function>
                Returns: <EventEmitter>
N
            if there are 7 listeners call this 7 times
            if an emit is in the middle of a listener stack nothing is                         D
                 remove until emit is done with the stack     
            file: EVENTS/remove_listener.js 

                  O
            N           if you need to turn your listeners on and off put the listener 
                        fuction object to a const as in FS/remove_listener.js 
                  E 


            if you use the once and on methods with the same listener and same event,
             it removes whichever came last 
            file: EVENTS/remove_listener_diff_adds.js 


                                                E


                                                O


                emitter.setMaxListeners(n)
                Added in: v0.3.5
                n <integer>
                Returns: <EventEmitter>      
N                                                                                   D
                allows the max listeners to be 
                modifed for the specific ee instance 
                set to 0 for infiintiy 

                                        E



emitter.rawListeners(eventName)
Added in: v9.4.0
eventName <string> | <symbol>
Returns: <Function[]>
what happens here is it holds on to your listener and can do really cool things
refer to this file and comment and uncooment different commands to see potential 
file: EVENTS/raw_listeners.js







        O
N               D
        E

Node Stream API 

it helps out when you got to deal with streams 
they are all instances of event emitter 
the stream module is used for developers who want to create new streams 

using streams first module
making new streams 2nd module 
Additional Notes  3rd section 


        O
N               D
        E

 four fundamental stream types     

 Writable
 Readable
 Duplex  - read and write 
 Transform - Duplex that can modify or transform data 

these streams operate on  strings and Buffer (or Uint8Array) objects.
streams are switched into object node when created, trying to switch an exisiting stream into object_nameode is not safe 



both Writable and Readable store data in an internal buffer 
use writable.writableBuffer or readable.readableBuffer to access 

the amnt of data buffered depepnds on  the highWaterMark for normal streams this is total # of objects 
for objectMOde streams this is a total # of objects 

data is Buffered in readable streams when the instance calls stream.push(chunk). 
If the consumer does not call stream.read() the data will sit in the buffer until its consumed 

once the buffer reaches highWaterMark size the stream will stop reading data from the resources 
it will stop calling its  readable._read()

data is BUffered in  Writable writable.write(chunk) called several times 
when the write buffer is below the highWaterMark it returns true 

the goal here is to limit the buffered data 

Duplex and Transform have their readable and writable buffer independent because the 
read-write speeds can change all the time

file STREAM/concept_stream.js
      EXPRESS/route_handler_handler/do_i_need_third_party.js

so whats basically happening here is that when nothing a triggering the readable and writable in streams 
nothing happens but streams are waiting for data events, thats when they can get a listeners to do something that how they work 

    write() and end() that are used to write data onto the stream.
    Readable streams use eventEmitter API  to notify application API when data is available to read off the stream 
    